import numpy as np
import pandas as pd


"""
Signal generation is based on processing a relatively small number of highly informative 
(point-wise) scores generated by ML algorithms. The goal is to apply some rules to these
scores and generate the final signal buy, sell or do nothing. Such rules are described via
a number of parameters. These parameters are chosen to optimize the final trade performance
(and not precision in ML algorithms). Thus we have two sets of functions: 1) computing rules with
given parameters, and 2) finding optimal parameters of rules (currently via grid search).
"""


def generate_smoothen_scores(df, config: dict):
    """
    Smoothen several columns and rows. Used for smoothing scores.
    """
    columns = config.get('columns')
    if not columns:
        raise ValueError(f"The 'columns' parameter must be a non-empty string. {type(columns)}")
    elif isinstance(columns, str):
        columns = [columns]

    out_column = df[columns].mean(skipna=True, axis=1)
    point_threshold = config.get("point_threshold")
    if point_threshold:
        out_column = out_column >= point_threshold

    window = config.get("window")
    if isinstance(window, int):
        out_column = out_column.rolling(window, min_periods=window // 2).mean()
    elif isinstance(window, float):
        out_column = out_column.ewm(span=window, min_periods=window // 2, adjust=False).mean()

    names = config.get('names')
    if not isinstance(names, str):
        raise ValueError(f"'names' parameter must be a non-empty string. {type(names)}")

    df[names] = out_column
    return df, [names]


def generate_combine_scores(df, config: dict):
    """
    ML algorithms predict score which is always positive and typically within [0,1].
    """
    columns = config.get('columns')
    if not columns:
        raise ValueError(f"The 'columns' parameter must be a non-empty string. {type(columns)}")
    elif not isinstance(columns, list) or len(columns) != 2:
        raise ValueError(f"'columns' parameter must be a list with buy column name and sell column name. {type(columns)}")

    up_column = columns[0]
    down_column = columns[1]
    out_column = config.get('names')

    if config.get("combine") == "relative":
        combine_scores_relative(df, up_column, down_column, out_column)
    elif config.get("combine") == "difference":
        combine_scores_difference(df, up_column, down_column, out_column)
    else:
        df[out_column] = df[[up_column, down_column]].apply(lambda x: x[0] if x[0] >= x[1] else -x[1], raw=True, axis=1)

    if config.get("coefficient"):
        df[out_column] = df[out_column] * config.get("coefficient")
    if config.get("constant"):
        df[out_column] = df[out_column] + config.get("constant")

    return df, [out_column]


def combine_scores_relative(df, buy_column, sell_column, trade_column_out):
    """
    Mutually adjust input buy and sell scores by producing two output scores.
    """
    buy_plus_sell = df[buy_column] + df[sell_column]
    buy_sell_score = ((df[buy_column] / buy_plus_sell) * 2) - 1.0
    df[trade_column_out] = buy_sell_score
    return buy_sell_score


def combine_scores_difference(df, buy_column, sell_column, trade_column_out):
    """
    This transformation represents how much buy score higher than sell score.
    """
    buy_minus_sell = df[buy_column] - df[sell_column]
    df[trade_column_out] = buy_minus_sell
    return buy_minus_sell


def compute_score_slope(df, model, buy_score_columns_in, sell_score_columns_in):
    """
    Experimental. Currently not used.
    """
    from scipy import stats

    def linear_regr_fn(X):
        X_array = np.asarray(range(len(X)))
        y_array = X
        if np.isnan(y_array).any():
            nans = ~np.isnan(y_array)
            X_array = X_array[nans]
            y_array = y_array[nans]
        slope, intercept, r, p, se = stats.linregress(X_array, y_array)
        return slope


def generate_threshold_rule(df, config):
    """
    Apply rules based on thresholds and generate trade signal buy, sell or do nothing.
    """
    parameters = config.get("parameters", {})
    columns = config.get("columns")
    if not columns:
        raise ValueError(f"The 'columns' parameter must be a non-empty string. {type(columns)}")
    elif isinstance(columns, list):
        columns = [columns]

    buy_signal_column = config.get("names")[0]
    sell_signal_column = config.get("names")[1]

    df[buy_signal_column] = (df[columns] >= parameters.get("buy_signal_threshold"))
    df[sell_signal_column] = (df[columns] <= parameters.get("sell_signal_threshold"))

    return df, [buy_signal_column, sell_signal_column]


def apply_rule_with_score_thresholds(df, score_column_names, model):
    """
    Apply rules based on thresholds and generate trade signal buy, sell or do nothing.
    """
    parameters = model.get("parameters", {})
    signal_column = model.get("signal_columns")[0]
    signal_column_2 = model.get("signal_columns")[1]
    score_column = score_column_names[0]

    df[signal_column] = (df[score_column] >= parameters.get("buy_signal_threshold"))
    df[signal_column_2] = (df[score_column] <= parameters.get("sell_signal_threshold"))


def generate_threshold_rule2(df, config):
    """
    Assume using difference combination with negative sell scores.
    """
    parameters = config.get("parameters", {})
    columns = config.get("columns")
    if not columns:
        raise ValueError(f"The 'columns' parameter must be a non-empty string. {type(columns)}")
    elif not isinstance(columns, list) or len(columns) != 2:
        raise ValueError(f"'columns' parameter must be a list with two column names. {type(columns)}")

    score_column = columns[0]
    score_column_2 = columns[1]
    buy_signal_column = config.get("names")[0]
    sell_signal_column = config.get("names")[1]

    df[buy_signal_column] = (df[score_column] >= parameters.get("buy_signal_threshold")) & (df[score_column_2] >= parameters.get("buy_signal_threshold_2"))
    df[sell_signal_column] = (df[score_column] <= parameters.get("sell_signal_threshold")) & (df[score_column_2] <= parameters.get("sell_signal_threshold_2"))

    return df, [buy_signal_column, sell_signal_column]


def apply_rule_with_slope_thresholds(df, model, buy_score_column, sell_score_column):
    """
    Experimental. Currently not used.
    """


def simulated_trade_performance(df, buy_signal_column, sell_signal_column, price_column):
    """
    Simulate trades over time by buying and selling the asset according to buy/sell signals.
    """
    is_buy_mode = True
    long_profit = 0
    long_profit_percent = 0
    long_transactions = 0
    long_profitable = 0
    longs = list()

    short_profit = 0
    short_profit_percent = 0
    short_transactions = 0
    short_profitable = 0
    shorts = list()

    df = df[[sell_signal_column, buy_signal_column, price_column]]
    for (index, sell_signal, buy_signal, price) in df.itertuples(name=None):
        if not price or pd.isnull(price):
            continue
        if is_buy_mode:
            if buy_signal:
                previous_price = shorts[-1][2] if len(shorts) > 0 else 0.0
                profit = (previous_price - price) if previous_price > 0 else 0.0
                profit_percent = 100.0 * profit / previous_price if previous_price > 0 else 0.0
                short_profit += profit
                short_profit_percent += profit_percent
                short_transactions += 1
                if profit > 0:
                    short_profitable += 1
                shorts.append((index, previous_price, price, profit, profit_percent))
                is_buy_mode = False
        else:
            if sell_signal:
                previous_price = longs[-1][2] if len(longs) > 0 else 0.0
                profit = (price - previous_price) if previous_price > 0 else 0.0
                profit_percent = 100.0 * profit / previous_price if previous_price > 0 else 0.0
                long_profit += profit
                long_profit_percent += profit_percent
                long_transactions += 1
                if profit > 0:
                    long_profitable += 1
                longs.append((index, previous_price, price, profit, profit_percent))
                is_buy_mode = True

    long_performance = dict(
        profit=long_profit,
        profit_percent=long_profit_percent,
        transaction_no=long_transactions,
        profitable=long_profitable / long_transactions if long_transactions else 0.0,
        transactions=longs,
    )
    short_performance = dict(
        profit=short_profit,
        profit_percent=short_profit_percent,
        transaction_no=short_transactions,
        profitable=short_profitable / short_transactions if short_transactions else 0.0,
        transactions=shorts,
    )

    profit = long_profit + short_profit
    profit_percent = long_profit_percent + short_profit_percent
    transaction_no = long_transactions + short_transactions
    profitable = (long_profitable + short_profitable) / transaction_no if transaction_no else 0.0
    performance = dict(
        profit=profit,
        profit_percent=profit_percent,
        transaction_no=transaction_no,
        profitable=profitable,
        profit_per_transaction=profit / transaction_no if transaction_no else 0.0,
        profitable_percent=100.0 * profitable / transaction_no if transaction_no else 0.0,
    )

    return performance, long_performance, short_performance


if __name__ == '__main__':
    df = pd.read_csv(r"C:\DATA_ITB\BTCUSDT\signals.csv", parse_dates=["timestamp"], nrows=100_000_000)
    df = df.dropna(subset=["close"])

    performance, long_performance, short_performance = simulated_trade_performance(df, 'sell_signal_column', 'buy_signal_column', 'close')
